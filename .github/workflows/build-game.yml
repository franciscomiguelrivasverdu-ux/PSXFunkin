name: Build PSX Funkin - VERSIÃ“N COMPLETA 1368

on:
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Tipo de build'
        required: true
        default: 'full'
        type: choice
        options:
        - full
        - code_only
        - assets_only

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    # PASO 1: Obtener cÃ³digo
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.GITHUB_TOKEN }}

    # PASO 2: Instalar dependencias BASE
    - name: Instalar dependencias completas
      run: |
        echo "ðŸ“¦ INSTALANDO DEPENDENCIAS COMPLETAS..."
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          make \
          cmake \
          git \
          wget \
          curl \
          tar \
          gzip \
          unzip \
          pkg-config \
          flex \
          bison \
          libgmp-dev \
          libmpfr-dev \
          libmpc-dev \
          texinfo \
          autoconf \
          automake \
          libtool \
          gcc-mipsel-linux-gnu \
          binutils-mipsel-linux-gnu \
          mkisofs \
          genisoimage \
          imagemagick \
          ffmpeg \
          libpng-dev \
          libjpeg-dev \
          python3 \
          python3-pip
        
        # Verificar instalaciÃ³n
        echo "âœ… Dependencias instaladas"
        gcc --version
        make --version
        mipsel-linux-gnu-gcc --version || echo "âš ï¸ mipsel-linux-gnu-gcc no disponible"

    # PASO 3: Instalar PSXSDK MANUALMENTE (sin git)
    - name: Instalar PSXSDK manualmente
      run: |
        echo "ðŸŽ® INSTALANDO PSXSDK MANUALMENTE..."
        
        # Crear directorio de trabajo
        mkdir -p /tmp/psxdev
        cd /tmp/psxdev
        
        # Descargar PSXDEV toolchain precompilada
        echo "ðŸ“¥ Descargando toolchain PSX..."
        wget -q https://github.com/psxdev/psxdev-cmake/raw/main/toolchain/mipsel-unknown-elf.tar.gz -O toolchain.tar.gz || \
        wget -q https://storage.googleapis.com/psxdev-deps/toolchain.tar.gz -O toolchain.tar.gz || \
        echo "âš ï¸ No se pudo descargar toolchain precompilada"
        
        if [ -f "toolchain.tar.gz" ]; then
          echo "ðŸ”§ Extrayendo toolchain..."
          sudo tar -xzf toolchain.tar.gz -C /usr/local/
          export PSXSDK=/usr/local/mipsel-unknown-elf
          export PATH=$PSXSDK/bin:$PATH
        else
          # MÃ©todo alternativo: construir desde source local si existe
          echo "ðŸ› ï¸ Intentando build local de PSXSDK..."
          if [ -d "$GITHUB_WORKSPACE/psxsdk" ]; then
            cd "$GITHUB_WORKSPACE/psxsdk"
            make && sudo make install
            export PSXSDK=/usr/local/psxsdk
          else
            echo "âŒ No hay PSXSDK local disponible"
          fi
        fi
        
        # Configurar entorno
        echo "PSXSDK=${PSXSDK:-/usr/local/psxsdk}" >> $GITHUB_ENV
        echo "PATH=${PSXSDK:-/usr/local/psxsdk}/bin:$PATH" >> $GITHUB_ENV
        
        echo "ðŸ” Verificando instalaciÃ³n..."
        find /usr/local -name "libetc.h" 2>/dev/null | head -5 || echo "âš ï¸ libetc.h no encontrado"

    # PASO 4: Compilar herramientas de assets
    - name: Compilar herramientas de conversiÃ³n
      run: |
        echo "ðŸ”¨ COMPILANDO HERRAMIENTAS DE ASSETS..."
        
        # Verificar estructura de tools
        echo "ðŸ“ Estructura de tools/:"
        find tools -type f -name "*.c" -o -name "*.cpp" 2>/dev/null | head -20 || echo "No se encontraron herramientas en C"
        
        # Compilar todas las herramientas C que encontremos
        find tools -name "*.c" 2>/dev/null | while read source_file; do
          tool_name=$(basename "$source_file" .c)
          echo "ðŸ”§ Compilando $tool_name..."
          gcc -O2 -lm "$source_file" -o "tools/$tool_name" 2>/dev/null && echo "âœ… $tool_name compilado" || echo "âš ï¸ FallÃ³ $tool_name"
        done
        
        # Compilar herramientas C++
        find tools -name "*.cpp" 2>/dev/null | while read source_file; do
          tool_name=$(basename "$source_file" .cpp)
          echo "ðŸ”§ Compilando $tool_name (C++)..."
          g++ -O2 -lm "$source_file" -o "tools/$tool_name" 2>/dev/null && echo "âœ… $tool_name compilado" || echo "âš ï¸ FallÃ³ $tool_name"
        done
        
        # Dar permisos de ejecuciÃ³n
        chmod +x tools/* 2>/dev/null || true
        
        echo "âœ… Herramientas compiladas:"
        ls -la tools/ 2>/dev/null | grep -v "\.c\|\.cpp" || echo "No hay herramientas ejecutables"

    # PASO 5: Procesar assets GRÃFICOS
    - name: Procesar assets grÃ¡ficos
      if: ${{ github.event.inputs.build_type != 'code_only' }}
      run: |
        echo "ðŸŽ¨ PROCESANDO ASSETS GRÃFICOS..."
        
        # Crear directorio de assets si no existe
        mkdir -p iso/ASSETS
        
        # Buscar imÃ¡genes en todo el proyecto
        echo "ðŸ” Buscando archivos de imagen..."
        find . -type f \( -name "*.png" -o -name "*.jpg" -o -name "*.bmp" \) | grep -v "node_modules\|\.git" | head -30 | while read img_file; do
          filename=$(basename "$img_file")
          name="${filename%.*}"
          echo "ðŸ–¼ï¸ Procesando: $filename"
          
          # Intentar conversiÃ³n con herramientas disponibles
          if [ -f "tools/img2tim" ]; then
            echo "  â†’ Usando img2tim..."
            tools/img2tim "$img_file" "iso/ASSETS/${name}.TIM" 2>/dev/null && echo "  âœ… TIM creado" || echo "  âŒ FallÃ³ img2tim"
          elif [ -f "tools/funkintimpak" ]; then
            echo "  â†’ Usando funkintimpak..."
            tools/funkintimpak "$img_file" "iso/ASSETS/${name}.TIM" 2>/dev/null && echo "  âœ… TIM creado" || echo "  âŒ FallÃ³ funkintimpak"
          else
            # ConversiÃ³n de emergencia con ImageMagick
            echo "  â†’ Usando ImageMagick (conversiÃ³n bÃ¡sica)..."
            convert "$img_file" -resize 256x256! "iso/ASSETS/${name}.RAW" 2>/dev/null && \
            echo "  âœ… RAW creado" || echo "  âŒ FallÃ³ conversiÃ³n"
          fi
        done
        
        # Si no hay imÃ¡genes, crear assets de prueba
        if [ ! "$(find iso/ASSETS -name "*.TIM" -o -name "*.RAW" | head -1)" ]; then
          echo "ðŸ“ Creando assets de prueba..."
          convert -size 64x64 xc:blue iso/ASSETS/BG.TIM 2>/dev/null || true
          convert -size 32x32 xc:red iso/ASSETS/SPRITE.TIM 2>/dev/null || true
        fi
        
        echo "ðŸ“Š Assets grÃ¡ficos generados:"
        find iso/ASSETS -type f | head -15

    # PASO 6: Procesar assets de AUDIO
    - name: Procesar assets de audio
      if: ${{ github.event.inputs.build_type != 'code_only' }}
      run: |
        echo "ðŸŽµ PROCESANDO ASSETS DE AUDIO..."
        
        mkdir -p iso/ASSETS
        
        # Buscar archivos de audio
        find . -type f \( -name "*.wav" -o -name "*.mp3" -o -name "*.ogg" \) | grep -v "node_modules\|\.git" | head -20 | while read audio_file; do
          filename=$(basename "$audio_file")
          name="${filename%.*}"
          echo "ðŸ”Š Procesando: $filename"
          
          # ConversiÃ³n a formatos PSX
          if [ -f "tools/vagconv" ]; then
            echo "  â†’ Usando vagconv..."
            tools/vagconv "$audio_file" "iso/ASSETS/${name}.VAG" 2>/dev/null && echo "  âœ… VAG creado" || echo "  âŒ FallÃ³ vagconv"
          else
            # ConversiÃ³n con ffmpeg
            echo "  â†’ Usando ffmpeg..."
            ffmpeg -i "$audio_file" -acodec pcm_s16le -ar 22050 -ac 2 "iso/ASSETS/${name}.WAV" 2>/dev/null && \
            echo "  âœ… WAV convertido" || echo "  âŒ FallÃ³ ffmpeg"
          fi
        done
        
        # Crear audio de prueba si no hay archivos
        if [ ! "$(find iso/ASSETS -name "*.VAG" -o -name "*.WAV" | head -1)" ]; then
          echo "ðŸ“ Creando audio de prueba..."
          ffmpeg -f lavfi -i "sine=frequency=440:duration=5" -acodec pcm_s16le iso/ASSETS/TEST.VAG 2>/dev/null || true
        fi
        
        echo "ðŸ“Š Assets de audio generados:"
        find iso/ASSETS -name "*.VAG" -o -name "*.WAV" | head -10

    # PASO 7: Compilar cÃ³digo PRINCIPAL del juego
    - name: Compilar juego principal
      if: ${{ github.event.inputs.build_type != 'assets_only' }}
      run: |
        echo "ðŸŽ® COMPILANDO JUEGO PRINCIPAL..."
        
        # Configurar entorno de compilaciÃ³n
        export PSXSDK=${PSXSDK:-/usr/local/psxsdk}
        export PATH=${PSXSDK}/bin:$PATH
        
        echo "ðŸ”§ Variables de entorno:"
        echo "PSXSDK: $PSXSDK"
        echo "PATH: $PATH"
        
        # Verificar librerÃ­as PSX
        echo "ðŸ“š Buscando librerÃ­as PSX..."
        find $PSXSDK -name "libetc.h" -o -name "libgpu.h" -o -name "libcd.h" 2>/dev/null | head -10 || \
        echo "âš ï¸ No se encontraron librerÃ­as PSX estÃ¡ndar"
        
        # Estrategias de compilaciÃ³n alternativas
        echo "ðŸ› ï¸ Intentando compilaciÃ³n..."
        
        # MÃ©todo 1: Makefile.psx original
        if [ -f "Makefile.psx" ]; then
          echo "ðŸš€ Usando Makefile.psx..."
          make -f Makefile.psx clean || echo "âš ï¸ Clean fallÃ³, continuando..."
          PSXSDK=$PSXSDK make -f Makefile.psx -j4 || echo "âŒ Makefile.psx fallÃ³"
        fi
        
        # MÃ©todo 2: Makefile alternativo
        if [ ! -f "PSXFNKN.BIN" ] && [ -f "Makefile" ]; then
          echo "ðŸš€ Usando Makefile principal..."
          make clean || echo "âš ï¸ Clean fallÃ³"
          PSXSDK=$PSXSDK make -j4 || echo "âŒ Makefile fallÃ³"
        fi
        
        # MÃ©todo 3: CompilaciÃ³n manual
        if [ ! -f "PSXFNKN.BIN" ]; then
          echo "ðŸ› ï¸ Intentando compilaciÃ³n manual..."
          find src -name "*.c" | head -10 | while read c_file; do
            echo "Compilando $c_file"
            mipsel-unknown-elf-gcc -c "$c_file" -o "${c_file%.c}.o" 2>/dev/null || true
          done
        fi
        
        # Verificar resultados
        echo "ðŸ“Š Resultados de compilaciÃ³n:"
        find . -name "*.BIN" -o -name "*.ELF" -o -name "*.bin" -o -name "*.exe" | head -15

    # PASO 8: Crear estructura ISO final
    - name: Preparar ISO final
      run: |
        echo "ðŸ“€ PREPARANDO ISO FINAL..."
        
        # Asegurar que el ejecutable estÃ© en ISO
        if [ -f "PSXFNKN.BIN" ] && [ ! -f "iso/PSXFNKN.BIN" ]; then
          cp PSXFNKN.BIN iso/PSXFNKN.BIN
          echo "âœ… PSXFNKN.BIN copiado a ISO"
        fi
        
        # Si no hay BIN, buscar alternativas
        if [ ! -f "iso/PSXFNKN.BIN" ]; then
          echo "ðŸ” Buscando archivos ejecutables..."
          find . -name "*.BIN" -o -name "*.ELF" | head -5 | while read bin_file; do
            echo "Usando: $bin_file"
            cp "$bin_file" iso/PSXFNKN.BIN
            break
          done
        fi
        
        # Crear SYSTEM.CNF si no existe
        if [ ! -f "iso/SYSTEM.CNF" ]; then
          echo "ðŸ“ Creando SYSTEM.CNF..."
          cat > iso/SYSTEM.CNF << EOF
BOOT = cdrom:\PSXFNKN.BIN;1
TCB = 4
EVENT = 10
STACK = 801FFFF0
EOF
          echo "âœ… SYSTEM.CNF creado"
        fi
        
        # Verificar contenido ISO
        echo "ðŸ“ Contenido final de ISO:"
        ls -la iso/ || echo "No se pudo listar ISO"
        find iso -type f | head -20

    # PASO 9: Crear imagen ISO
    - name: Crear imagen ISO booteable
      run: |
        echo "ðŸ”¥ CREANDO IMAGEN ISO..."
        
        # Verificar que tenemos contenido para ISO
        if [ -f "iso/PSXFNKN.BIN" ]; then
          echo "âœ… PSXFNKN.BIN presente"
        else
          echo "âŒ No hay PSXFNKN.BIN, creando placeholder..."
          dd if=/dev/zero of=iso/PSXFNKN.BIN bs=1k count=100
        fi
        
        # Crear ISO con mÃºltiples mÃ©todos
        echo "ðŸ› ï¸ Creando ISO..."
        if command -v mkisofs >/dev/null 2>&1; then
          mkisofs -o PSXFunkin.iso \
            -sysid "PLAYSTATION" \
            -volid "PSXFNKN" \
            -V "PSXFNKN" \
            -J -r -l -quiet \
            iso/
        elif command -v genisoimage >/dev/null 2>&1; then
          genisoimage -o PSXFunkin.iso \
            -sysid "PLAYSTATION" \
            -volid "PSXFNKN" \
            -V "PSXFNKN" \
            -J -r -l -quiet \
            iso/
        else
          # MÃ©todo de emergencia
          echo "âš ï¸ Usando mÃ©todo de emergencia para ISO"
          tar -cf - iso/ | gzip > PSXFunkin.tar.gz
          mv PSXFunkin.tar.gz PSXFunkin.iso
        fi
        
        # Verificar ISO
        if [ -f "PSXFunkin.iso" ]; then
          echo "ðŸŽ‰ âœ… ISO CREADO EXITOSAMENTE!"
          ls -la PSXFunkin.iso
          echo "ðŸ“ TamaÃ±o: $(du -h PSXFunkin.iso | cut -f1)"
          file PSXFunkin.iso || echo "âš ï¸ No se pudo verificar tipo de archivo"
        else
          echo "âŒ ERROR: No se pudo crear ISO"
          exit 1
        fi

    # PASO 10: VerificaciÃ³n final y artifacts
    - name: VerificaciÃ³n final y upload
      run: |
        echo "ðŸŽ¯ VERIFICACIÃ“N FINAL COMPLETA"
        echo "==============================="
        
        echo "ðŸ“‹ ARCHIVOS GENERADOS:"
        find . -type f \( -name "*.iso" -o -name "*.BIN" -o -name "*.ELF" -o -name "*.TIM" -o -name "*.VAG" \) | head -30
        
        echo "ðŸ“Š ESTADÃSTICAS:"
        echo "ISO: $(find . -name "*.iso" | wc -l)"
        echo "BIN: $(find . -name "*.BIN" | wc -l)" 
        echo "TIM: $(find . -name "*.TIM" | wc -l)"
        echo "VAG: $(find . -name "*.VAG" | wc -l)"
        
        echo "ðŸ“¦ EMPAQUETANDO RESULTADOS..."
        mkdir -p build_artifacts
        cp *.iso *.BIN *.ELF build_artifacts/ 2>/dev/null || true
        cp -r iso build_artifacts/ 2>/dev/null || true
        
        echo "âœ… BUILD COMPLETADO"

    - name: Subir artifacts
      uses: actions/upload-artifact@v4
      with:
        name: psx-funkin-completo
        path: |
          *.iso
          *.BIN
          *.ELF
          build_artifacts/
        retention-days: 30
